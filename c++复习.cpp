1.程序产物的存储
/*
编译链接过程
程序员的自我修养


数据 : 全局量   静态量
指令：数据以外全部是指令

执行文件:
数据：  .data     .bss
指令：  .text

.rodata : 
常量   --- “aaaa”
vftable     RTTI结构

.data：
有初始化，且初始化不为0的数据
     
.bss
没有初始化或者初始化为0的数据
在文件中.bss段不占空间

符号表：
数据都会产生符号
函数名会产生符号


运行
数据存储在虚拟地址空间

.data:
有初始化且初始化不为0的数据

.bss
没有初始化或者初始化为0的数据

.text
存储指令

.rodata
常量   --- “aaaa”
vftable     RTTI结构

虚拟地址空间从可执行文件中读取数据依赖的是 执行文件中的load页


运行需要的内存
stack：
函数栈帧   ---  在函数中定义的局部量

heap：
动态空间  --- malloc free   new  delete    
*/

#include<studio.h>
#define A 10
int a;   //数据
static int b //数据
void fun()   //指令
{}
int main()   ///指令
{
	static int c;  //数据
	int d = A;
	……
}

/*
struct 和  class
c语言中使用struct定义结构体
在c++中使用struct或者class定义类
c语言中struct里面不能定义成员方法和访问权限
c++中struct可以定义成员方法和访问权限
c++中struct默认权限为public
c语言中struct最小内存可以为0，c++中最小是1
c++中class可以用来写模板,但是struct不可以
*/


/*
c++和C相互调用
c语言产生的函数符号依赖的函数名
c++中产生函数符号依赖的是函数名+参数列表

c++中引用C语言：
在c++中声明C语言函数时候,加上extern"C"


c语言中引用c++：

*/
a.cpp:

/// fun_c_void
//int fun_c();

extern "C"//使用C语言的方式进行编译
{
	//fun_c
	int fun_c();
}

//fun_cpp_void 
int fun_cpp()
{}


int main()
{
	
	fun_c();	
}

aa.cpp:

//fun_cpp_void
void fun_cpp;

extern "C"
{
	//fun_c_cpp
	void fun_c_cpp()
	{
		fun_cpp();
	}
}


b.c:

//fun_c
int fun_c()
{
	
}

//fun_cpp
//void fun_cpp();

//fun_c_cpp
void fun_c_cpp();

int main()
{
	fun_c_cpp();
}



/*
const
c和c+中const的区别

左值 ：
int a;  可以放在等号左边的量

右值 ：
const int a;  10    不可以放在等号左边的量 


常量:
10   20  'a'     不可能改变的量，常量没有地址

常量字符串：
"aaaa"  
const char* p = "aaa";

常变量:
不可以作为左值，有地址

C语言中const
修饰的是常变量
const int a = 10;
a = 20;error
const int *p  =&a;
*((int*)p) = 20;

cout<<a<<endl;//20


常量：c+中
int c= 20;
const int a = c ;
int b = a;
const int *p = &a;
*((int*)p) = 20;
cout<<*p<<endl;//20
cout<<a<<endl;10
//编译期间就会将所有使用的a的地方替换为a的值
c++中的cosnt修饰的量必须初始化
常量必须使用常量初始化

c++中的常变量：
c++ 中如果使用变量初始化const修饰的量，const修饰的量就会退化为常变量
*/

/*
引用   
int a = 10;
int &aa = a ;
aa = 20;
int c = aa;

引用相当于是别名 
引用的底层其实是 指针
引用在使用到该引用的地方，在编译期间会自动替换为指针的解引用
所以引用一旦初始化，就无法改变引用的指向
所以引用必须初始化


引用和指针的区别
引用底层就是指针
引用在使用到该引用的地方，在编译期间会自动替换为指针的解引用
引用相对于指针更方便使用
引用无法改变引用的对象
*/


/*
inline     只是建议系统将该函数处理成内联
递归函数无法处理成内联

宏函数：
会在调用点展开----预编译期
作用域只在本文件
不产生符号
不可以调试
没有类型判断


内联：
在release版本中会在调用点展开   --- 编译期间展开
作用域只在本文件
release版本中不产生符号，debug版本产生local符号
在debug版本可以调试
有类型判断

static：
不展开
作用域只在本文件
产生local符号
可以调试
有类型判断
*/


/*
c++中那些替代了c语言中的宏的使用


文本替代宏
#define AAA 10     ----  预编译期间进行文本替换  

const     -----  编译期进行值替换


宏函数   ----  预编译期间进行文本替换 

内联函数替代    ---- 编译期间进行逻辑替换

*/


//////面向对象

三大特征：封装  继承    多态
四大特征：抽象  封装    继承   多态

/*
构造函数：
构造函数是在对象实例化的时候调用的成员方法
如果没有自己实现构造函数，系统会自动产生一个默认构造函数，这个函数什么都不做
如果自己实现了构造函数，系统就不会在生成默认构造了

构造函数可以存在多个，参数列表不同即可，相互之间存在重载关系
*/

/*
拷贝构造函数
拷贝构造函数是在使用已存在的对象生成新对象的过程中调用的成员方法
如果没有自己实现拷贝构造函数，系统会自动产生一个拷贝构造函数，这个拷贝构造函数是浅拷贝
如果自己实现了拷贝构造函数，系统就不会在生成了
拷贝构造函数只有一个


注意：
1.参数必须传引用-------防止参数传递死递归
2.防止浅拷贝
*/

/*
析构函数

析构函数是在对象生存周期满的时候自动调用的成员方法
如果没有实现，系统会默认生成一个，但是生成的析构函数啥都不做
自己实现了，系统就不会生成了

注意：
防止内存泄漏
*/


/*
=运算符重载

在使用已存在的对象给已存在的对象赋值过程中自动调用的
如果没有实现，系统会自动生成一个浅拷贝的=运算符重载
自己实现了就不会生成了

注意：
防止自赋值
防止内存泄漏
防止浅拷贝
*/

/*
new   delete     是运算符

new：
new operator : 一般使用的（不能重载）
---》operator new（申请内存） ---》调用构造
operator new ： 允许重载的  ---用来申请内存

delete :
delete operator: 一般使用的（不能重载）
---》调用析构     ----》释放内存（operator delete）
operator delete：允许重载  -----   用来释放内存

*/

/*
运算符：
大数  +  -
*/



/*
this指针

指向源对象自身的指针

在非静态成员方法的形参列表第一个位置，默认加上this指针，编译期间生成指令时候加上的
在调用的非静态成员方法的实参列表第一个位置，默认加上this指针，编译期间生成指令时候加上的
在非静态成员方法体内，使用到非静态成员的地方，默认加上this->,编译期间生成指令时候加上的

成员方法内无法改变this指针的指向，所以参数中的是
SUB * const this 

this = NULL；error
*/


/*
const方法

在成员方法的参数列表后面加上const
void fun()const{}

const修饰的是this指针
const SUB* const this

const成员方法中不允许改变该对象成员
this->a = 10;///error


常对象只能使用常方法---
因为常对象的this指针是常指针
常方法当中也只能使用常方法

建议：
成员方法中如果没有改变对象的成员就将该方法写成常方法


*/





